<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Control Surface: Frequently Asked Questions</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&family=Roboto:wght@400&family=Roboto:wght@500&display=swap" rel="stylesheet">
<link href="../../custom_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Control Surface<span id="projectnumber">&#160;<code><a href="/Control-Surface/">develop</a></code></span>
   </div>
   <div id="projectbrief">MIDI Control Surface library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Frequently Asked Questions </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#faq-terminology">Terminology</a></li>
<li class="level1"><a href="#faq-midi">Can I use Control Surface as a general purpose MIDI library?</a><ul><li class="level2"><a href="#faq-send-midi">Sending MIDI</a></li>
<li class="level2"><a href="#faq-recv-midi">Receiving MIDI</a></li>
<li class="level2"><a href="#faq-route-midi">Routing MIDI</a></li>
<li class="level2"><a href="#faq-midi-examples">MIDI examples</a></li>
<li class="level2"><a href="#fac-midi-combine-control-surface">Combining low-level MIDI code and high-level “Control Surface” code</a></li>
</ul>
</li>
<li class="level1"><a href="#faq-mux-encoder">Can I use multiplexers for reading rotary encoders?</a></li>
<li class="level1"><a href="#faq-change-address-runtime">Can I change the address, controller number, MIDI channel, etc. at runtime?</a></li>
<li class="level1"><a href="#faq-banks">How do banks work?</a><ul><li class="level2"><a href="#faq-normal-banks">Normal banks</a></li>
<li class="level2"><a href="#faq-banks-many-addresses">Many addresses</a></li>
</ul>
</li>
<li class="level1"><a href="#faq-add-display-support">How can I add support for different kinds of displays?</a></li>
<li class="level1"><a href="#faq-save-memory">How can I save memory when running out of RAM?</a><ul><li class="level2"><a href="#faq-save-memory-number-of-individual-elements">Reducing the number of individual MIDI elements</a></li>
<li class="level2"><a href="#faq-save-memory-disable-components">Disabling memory-hungry components</a></li>
</ul>
</li>
<li class="level1"><a href="#faq-midi-note-f">Why do I get a compiler error when using the note F?</a></li>
<li class="level1"><a href="#faq-control-surface-vs-midi-controller">What&#39;s the difference between the Control Surface and MIDI Controller libraries?</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_pages_FAQ"></a></p>
<h1><a class="anchor" id="faq-terminology"></a>
Terminology</h1>
<ul>
<li><b>MIDI Output Element</b>: Any component of a MIDI controller that sends out MIDI messages (e.g. a push button or a potentiometer).</li>
<li><b>MIDI Input Element</b>: Any component of a MIDI controller that listens for incoming MIDI messages (e.g. an LED that indicates the “mute” or “solo” status of a track, or a display with a level meter that shows the level of the audio playing in the DAW).</li>
<li><b>MIDI Element</b>: Broad term for both MIDI Output Elements and MIDI Input Elements. It usually refers to both the actual hardware (e.g. a push button) and the software object that reads the hardware and sends or receives the MIDI messages (e.g. a <code><a class="el" href="../../d1/d9f/classNoteButton.html" title="A class of MIDIOutputElements that read the input of a momentary push button or switch,...">NoteButton</a></code> object or variable in the Arduino code).</li>
</ul>
<h1><a class="anchor" id="faq-midi"></a>
Can I use Control Surface as a general purpose MIDI library?</h1>
<p >Absolutely! Even though Control Surface has many high-level utilities for building MIDI controllers, at its core is a solid MIDI input/output system with well-tested MIDI interfaces and MIDI parsers for many different transports, such as the classic 5-pin DIN MIDI, MIDI over USB and MIDI over Bluetooth Low Energy. There's also a Debug MIDI interface that prints the MIDI messages to the serial monitor, and there are wrappers for using third-party libraries such as AppleMIDI. See the <a class="el" href="../../dc/df0/group__MIDIInterfaces.html">MIDI Interfaces</a> module for a complete overview of the available MIDI interfaces. The <a class="el" href="../../d3/df7/midi-tutorial.html">MIDI Tutorial</a> goes into much more detail about sending, receiving and routing MIDI, but below are the basics:</p>
<h2><a class="anchor" id="faq-send-midi"></a>
Sending MIDI</h2>
<p >You can use the functions defined by the <a class="el" href="../../d6/d72/classMIDI__Sender.html">MIDI_Sender</a> class to send all kinds of MIDI messages. These functions can be used on all <a class="el" href="../../dc/df0/group__MIDIInterfaces.html">MIDI interfaces</a> and on the main <code>Control_Surface</code> class.</p>
<p >Here's a basic MIDI output example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="../../de/d05/classUSBMIDI__Interface.html">USBMIDI_Interface</a> midi; <span class="comment">// Instantiate the MIDI over USB interface</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="../../d7/d0f/classMIDIAddress.html">MIDIAddress</a> noteAddress = {<a class="code hl_variable" href="../../d7/d78/namespaceMIDI__Notes.html#adc612a1e4e057463777480eabc3fb0ca">MIDI_Notes::C</a>(4), <a class="code hl_variable" href="../../d7/d42/Channel_8hpp.html#a40d189f24e13a7304f2c9094038588ae">Channel_1</a>};</div>
<div class="line"><span class="keyword">const</span> uint8_t velocity = 0x7F;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  midi.<a class="code hl_function" href="../../dd/d0e/classGenericUSBMIDI__Interface.html#a7c3e14d99bd3dc0e3670d6956dafcaf2">begin</a>();       <span class="comment">// initialize the MIDI interface</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> loop() {</div>
<div class="line">  midi.<a class="code hl_function" href="../../d6/d72/classMIDI__Sender.html#ad487d041b8e9d10d58aba470a15e1fc6">sendNoteOn</a>(noteAddress, velocity);         <span class="comment">// send a note on event</span></div>
<div class="line">  delay(1000);</div>
<div class="line">  midi.<a class="code hl_function" href="../../d6/d72/classMIDI__Sender.html#ae5438982b69a41d7b4565328f5fd73c8">sendNoteOff</a>(noteAddress, velocity);        <span class="comment">// send a note off event</span></div>
<div class="line">  delay(1000);</div>
<div class="line">}</div>
<div class="ttc" id="aChannel_8hpp_html_a40d189f24e13a7304f2c9094038588ae"><div class="ttname"><a href="../../d7/d42/Channel_8hpp.html#a40d189f24e13a7304f2c9094038588ae">Channel_1</a></div><div class="ttdeci">constexpr Channel Channel_1</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/d42/Channel_8hpp_source.html#l00118">Channel.hpp:118</a></div></div>
<div class="ttc" id="aclassGenericUSBMIDI__Interface_html_a7c3e14d99bd3dc0e3670d6956dafcaf2"><div class="ttname"><a href="../../dd/d0e/classGenericUSBMIDI__Interface.html#a7c3e14d99bd3dc0e3670d6956dafcaf2">GenericUSBMIDI_Interface::begin</a></div><div class="ttdeci">void begin() override</div><div class="ttdoc">Initialize the MIDI Interface.</div></div>
<div class="ttc" id="aclassMIDIAddress_html"><div class="ttname"><a href="../../d7/d0f/classMIDIAddress.html">MIDIAddress</a></div><div class="ttdoc">A type-safe utility class for saving a MIDI address consisting of a 7-bit address,...</div><div class="ttdef"><b>Definition:</b> <a href="../../db/dd6/MIDIAddress_8hpp_source.html#l00145">MIDIAddress.hpp:145</a></div></div>
<div class="ttc" id="aclassMIDI__Sender_html_ad487d041b8e9d10d58aba470a15e1fc6"><div class="ttname"><a href="../../d6/d72/classMIDI__Sender.html#ad487d041b8e9d10d58aba470a15e1fc6">MIDI_Sender::sendNoteOn</a></div><div class="ttdeci">void sendNoteOn(MIDIAddress address, uint8_t velocity)</div><div class="ttdoc">Send a MIDI Note On event.</div></div>
<div class="ttc" id="aclassMIDI__Sender_html_ae5438982b69a41d7b4565328f5fd73c8"><div class="ttname"><a href="../../d6/d72/classMIDI__Sender.html#ae5438982b69a41d7b4565328f5fd73c8">MIDI_Sender::sendNoteOff</a></div><div class="ttdeci">void sendNoteOff(MIDIAddress address, uint8_t velocity)</div><div class="ttdoc">Send a MIDI Note Off event.</div></div>
<div class="ttc" id="aclassUSBMIDI__Interface_html"><div class="ttname"><a href="../../de/d05/classUSBMIDI__Interface.html">USBMIDI_Interface</a></div><div class="ttdoc">A class for MIDI interfaces sending MIDI messages over a USB MIDI connection.</div><div class="ttdef"><b>Definition:</b> <a href="../../d1/d64/USBMIDI__Interface_8hpp_source.html#l00148">USBMIDI_Interface.hpp:149</a></div></div>
<div class="ttc" id="anamespaceMIDI__Notes_html_adc612a1e4e057463777480eabc3fb0ca"><div class="ttname"><a href="../../d7/d78/namespaceMIDI__Notes.html#adc612a1e4e057463777480eabc3fb0ca">MIDI_Notes::C</a></div><div class="ttdeci">constexpr Note C</div><div class="ttdoc">C (Do)</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/dc5/Notes_8hpp_source.html#l00040">Notes.hpp:40</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="faq-recv-midi"></a>
Receiving MIDI</h2>
<p >For MIDI input, a class with callback functions for the different messages is used. When an incoming MIDI message is available, <code>midi.update()</code> will call the callbacks for you. See the <a class="el" href="../../de/d55/classMIDI__Callbacks.html">MIDI_Callbacks</a> class and the examples listed below.</p>
<h2><a class="anchor" id="faq-route-midi"></a>
Routing MIDI</h2>
<p >Apart from low-level MIDI input/output, you can also set up advanced MIDI routing rules between different interfaces. Two or more interfaces are connected through <a class="el" href="../../df/d72/classMIDI__Pipe.html">MIDI Pipes</a>. The simplest pipe just carries messages from the input interface to the output interface, but you can write rules for filtering out certain messages, changing the channel of some messages, etc. <br  />
 For more information, see the <a class="el" href="../../df/ddc/group__MIDI__Routing.html">MIDI Routing</a> module.</p>
<h2><a class="anchor" id="faq-midi-examples"></a>
MIDI examples</h2>
<ul>
<li><a class="el" href="../../d8/d9b/MIDI-Output_8ino-example.html">MIDI-Output.ino</a></li>
<li><a class="el" href="../../d7/d8d/Send-MIDI-Notes_8ino-example.html">Send-MIDI-Notes.ino</a></li>
<li><a class="el" href="../../d5/d35/Send-All-MIDI-Messages_8ino-example.html">Send-All-MIDI-Messages.ino</a></li>
<li><a class="el" href="../../d2/d93/SysEx-Send-Receive_8ino-example.html">SysEx-Send-Receive.ino</a></li>
<li><a class="el" href="../../d1/d5d/MIDI-Input_8ino-example.html">MIDI-Input.ino</a></li>
<li><a class="el" href="../../d4/d2b/MIDI-Input-Fine-Grained_8ino-example.html">MIDI-Input-Fine-Grained.ino</a></li>
<li><a class="el" href="../../da/d27/MIDI-Input-Fine-Grained-All-Callbacks_8ino-example.html">MIDI-Input-Fine-Grained-All-Callbacks.ino</a></li>
<li><a class="el" href="../../d0/dc4/MIDI_Pipes-Routing_8ino-example.html">MIDI_Pipes-Routing.ino</a></li>
<li><a class="el" href="../../dc/d0b/MIDI-Monitor_8ino-example.html">MIDI-Monitor.ino</a></li>
</ul>
<h2><a class="anchor" id="fac-midi-combine-control-surface"></a>
Combining low-level MIDI code and high-level “Control Surface” code</h2>
<p >If need access to the incoming MIDI messages while also using the high-level <code>Control_Surface</code> class, you can also add callbacks to <code>Control_Surface</code> itself. You can then decide whether or not you want to pass on the the message to <code>Control_Surface</code> when you're done with it. See the <a class="el" href="../../d0/d32/MIDI-Input-Callback_8ino-example.html">MIDI-Input-Callback.ino</a> example for more details. <br  />
 If you just want to use the low-level sending functions, you can either use the member functions of <code>Control_Surface</code>, like <code>Control_Surface.sendNoteOn(note, velocity)</code>, or you can use the MIDI interfaces directly.</p>
<h1><a class="anchor" id="faq-mux-encoder"></a>
Can I use multiplexers for reading rotary encoders?</h1>
<p >No, rotary encoders either need interrupts or have to be polled at a sufficiently high rate to work correctly, otherwise, you'll miss pulses when turning the encoder too quickly. Multiplexers generally do not generate interrupts when the inputs change, and polling them is often too slow. If your code contains other slow operations, such as updating a display or reading many analog inputs, polling is no longer an option.</p>
<p >If you can, try to connect rotary encoders to the Arduino directly, with at least one interrupt pin per encoder, preferably two.</p>
<p >If that's not an option because you're running out of pins, you can use a port expander, such as the MCP23017. These chips can be configured to generate an interrupt whenever one of the inputs changes, and also have built-in pull-up resistors, which is handy. <br  />
 To read encoders with the MCP23017 in an interrupt-driven way, the microcontroller should support I²C inside of an ISR (Interrupt Service Routine), in order to communicate with the port expander to check which pin changed. Not all microcontrollers support this, but the ARM processors of the Teensy 3.x and 4.x lines do. <br  />
 If I²C communication is not possible inside of an ISR (AVR Arduino boards, ESP32, etc.), you can still use polling, on the condition that the rest of your code doesn't take too long.</p>
<p >There are two examples for using rotary encoders with a MCP23017:</p><ul>
<li><a class="el" href="../../dd/d56/MCP23017-RotaryEncoder-Interrupts_8ino-example.html">MCP23017-RotaryEncoder-Interrupts.ino</a> (Teensy)</li>
<li><a class="el" href="../../d7/dac/MCP23017-RotaryEncoder-No-Interrupts_8ino-example.html">MCP23017-RotaryEncoder-No-Interrupts.ino</a> (Other boards)</li>
</ul>
<h1><a class="anchor" id="faq-change-address-runtime"></a>
Can I change the address, controller number, MIDI channel, etc. at runtime?</h1>
<p >Yes, this is done through banks. See the <a class="el" href="../../d0/d74/Bank_8ino-example.html">Bank.ino</a> example. <br  />
 The standard <a class="el" href="../../d2/d00/group__BankableMIDIOutputElements.html">Bankable MIDI Output Elements</a> have fixed offsets between the different addresses (e.g. address bank 1 = controller #8, bank 2 = controller #16, bank 3 = controller #24 and bank 4 = controller #32), while the <a class="el" href="../../d3/dc0/group__ManyAddressesMIDIOutputElements.html">Many Addresses MIDI Output Elements</a> allow you to specify arbitrary addresses, they don't need to have a fixed offset between them.</p>
<h1><a class="anchor" id="faq-banks"></a>
How do banks work?</h1>
<p >There are two kinds of “Bankable” MIDI Elements: the standard <code><a class="el" href="../../d1/dd0/namespaceBankable.html" title="A namespace for MIDI elements that can be added to a Bank, to change their address or channel.">Bankable</a></code> elements and the <code><a class="el" href="../../db/d14/namespaceBankable_1_1ManyAddresses.html">Bankable::ManyAddresses</a></code> elements.</p>
<h2><a class="anchor" id="faq-normal-banks"></a>
Normal banks</h2>
<p >Normal <code><a class="el" href="../../d1/dd0/namespaceBankable.html" title="A namespace for MIDI elements that can be added to a Bank, to change their address or channel.">Bankable</a></code> elements allow you to change the address of the element by multiples of a fixed offset. You can change the MIDI address (such as controller number or note number), the MIDI channel or the MIDI USB virtual cable number of the <code><a class="el" href="../../d1/dd0/namespaceBankable.html" title="A namespace for MIDI elements that can be added to a Bank, to change their address or channel.">Bankable</a></code> element. <br  />
 The formula for the address is a linear function of the active bank: </p><p class="formulaDsp">
\[ y = ax + b, \]
</p>
<p> where \( y \) is the effective address, \( a \) is the fixed offset between banks, \( x \) is the currently selected bank ( \( x=0 \) is the first bank), and \( b \) is the base address, which is the address when the first bank is selected. The offset \( a \) is a property of the <a class="el" href="../../db/dbd/classBank.html" title="A class that groups Bankable MIDI Output Elements and Bankable MIDI Input Elements,...">Bank</a>, and the base address \( b \) is a property of the <code><a class="el" href="../../d1/dd0/namespaceBankable.html" title="A namespace for MIDI elements that can be added to a Bank, to change their address or channel.">Bankable</a></code> MIDI element.</p>
<p >This formula is rather abstract, and it might not immediately be clear why this is useful, so I'd recommend playing around some with the <a class="el" href="../../d0/d74/Bank_8ino-example.html">Bank.ino</a> example.</p>
<p >Another example is the following: imagine that you want to mute or un-mute any of the 12 audio tracks in your DAW using only 4 physical buttons. In that case, you could use 3 banks to change the addresses of the buttons. When the first bank is selected, the first button mutes track 1, the second button mutes track 2, etc. When the second bank is selected, the first button mutes track 5, the second button mutes track 6, and so on. <br  />
 In this example, the offset \( a \) is 4, the number of buttons, or the number of tracks you can control per bank. The base address \( b \) of the first button is 1, for the second button, it's 2, for the third button, it's 3, and so on.</p>
<p >Click the buttons in the animation below to get a feel for how it works:</p>
<p > 
<object type="image/svg+xml" data="../../bank-bankable.svg" style="margin: 0 auto; display: block"></object>
</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../db/dbd/classBank.html">Bank&lt;3&gt;</a> bank(4); <span class="comment">// 3 banks with an offset of 4 tracks per bank (a = 4)</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="../../de/d36/classBankable_1_1NoteButton.html">Bankable::NoteButton</a> muteButtons[] {</div>
<div class="line">    {bank, pin1, 1}, <span class="comment">// base address 1 (b = 1)</span></div>
<div class="line">    {bank, pin2, 2}, <span class="comment">// base address 2 (b = 2)</span></div>
<div class="line">    {bank, pin3, 3}, <span class="comment">// base address 3 (b = 3)</span></div>
<div class="line">    {bank, pin4, 4}, <span class="comment">// base address 4 (b = 4)</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassBank_html"><div class="ttname"><a href="../../db/dbd/classBank.html">Bank</a></div><div class="ttdoc">A class that groups Bankable MIDI Output Elements and Bankable MIDI Input Elements,...</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d57/Bank_8hpp_source.html#l00091">Bank.hpp:91</a></div></div>
<div class="ttc" id="aclassBankable_1_1NoteButton_html"><div class="ttname"><a href="../../de/d36/classBankable_1_1NoteButton.html">Bankable::NoteButton</a></div><div class="ttdoc">A class of MIDIOutputElements that read the input of a momentary push button or switch,...</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d8e/Bankable_2NoteButton_8hpp_source.html#l00022">Bankable/NoteButton.hpp:22</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="faq-banks-many-addresses"></a>
Many addresses</h2>
<p >In most cases, the standard <code><a class="el" href="../../d1/dd0/namespaceBankable.html" title="A namespace for MIDI elements that can be added to a Bank, to change their address or channel.">Bankable</a></code> elements are sufficient, but sometimes, you might need a more flexible solution. The <code><a class="el" href="../../db/d14/namespaceBankable_1_1ManyAddresses.html">Bankable::ManyAddresses</a></code> elements allow you to specify an arbitrary list of alternative addresses. The formula for the address is simply a table lookup in that list of addresses, based on the active bank: </p><p class="formulaDsp">
\[ y = \text{list of addresses}[x] \]
</p>
<p>.</p>
<h1><a class="anchor" id="faq-add-display-support"></a>
How can I add support for different kinds of displays?</h1>
<p >Out of the box, the library supports SSD1306 OLED displays. Adding support for other types of displays is relatively easy, by implementing the <code><a class="el" href="../../df/d42/classDisplayInterface.html" title="An interface for displays.">DisplayInterface</a></code> API.</p>
<p ><code><a class="el" href="../../df/d42/classDisplayInterface.html" title="An interface for displays.">DisplayInterface</a></code> is an abstract interface: it declares a set of abstract (pure virtual) drawing functions for displays. Control Surface uses these functions to draw to the displays, but Control Surface doesn't know how these functions are implemented, the implementation depends on the display library you're using, and it's up to the user to create an adapter between Control Surface and the display library by implementing the pure virtual functions of <code><a class="el" href="../../df/d42/classDisplayInterface.html" title="An interface for displays.">DisplayInterface</a></code>.</p>
<p >As an example, you could have a look at the <a href="https://github.com/tttapa/Control-Surface/blob/main/src/Display/DisplayInterfaces/DisplayInterfaceSSD1306.hpp"><code>DisplayInterfaceSSD1306</code></a>, it should be almost identical for other Adafruit libraries, and writing adapters for other types of display libraries.</p>
<h1><a class="anchor" id="faq-save-memory"></a>
How can I save memory when running out of RAM?</h1>
<h2><a class="anchor" id="faq-save-memory-number-of-individual-elements"></a>
Reducing the number of individual MIDI elements</h2>
<p >Each individual MIDI element you create has some extra overhead to allow Control Surface to do its thing, such as automatically initializing and updating the element, notifying it of bank changes, etc. <br  />
 When you instantiate dozens or even hundreds of these elements, the overhead adds up, and you might find that your board doesn't have enough memory available to run your program.</p>
<p >To get around this problem, the first step would be to combine many elements into one. For example, if you have an array of 32 <a class="el" href="../../d2/daa/classCCButton.html">CCButton</a> elements, replace it with a single <a class="el" href="../../d0/dd3/classCCButtons.html">CCButtons&lt;32&gt;</a> element. If you have 32 <a class="el" href="../../d7/de4/group__midi-input-elements-leds.html#ga07cc4e7d46065d55d2f3f814d0c80528">NoteLED</a> elements, replace it with a single <a class="el" href="../../d7/de4/group__midi-input-elements-leds.html#ga9e22f68f83d1f65746c50865eada8d15">NoteRangeLEDs&lt;32&gt;</a> element.</p>
<p >Not all MIDI elements have an alternative that can handle many inputs or outputs at once. If the one for your particular use case is missing, feel free to open an issue with a feature request. You can also try to add it yourself by implementing a custom MIDI element as shown in <a class="el" href="../../d4/d3b/Custom-MIDI-Output-Element_8ino-example.html">Custom-MIDI-Output-Element.ino</a></p>
<h2><a class="anchor" id="faq-save-memory-disable-components"></a>
Disabling memory-hungry components</h2>
<p >If that's not enough, you could try disabling some of the features of the library that you don't need. For example, if you don't need to be able to receive MIDI System Exclusive messages, you can turn on the <a class="el" href="../../dc/d4f/Settings_2Settings_8hpp.html#a2a82e3cbc4ddcf68ac47d0d464189e35">IGNORE_SYSEX</a> and <a class="el" href="../../dc/d4f/Settings_2Settings_8hpp.html#aaae4753367a4adac0c45a92bad885e5c">NO_SYSEX_OUTPUT</a> settings in src/Settings/Settings.hpp. If you do need SysEx support but still want to save some memory, you can try decreasing the <a class="el" href="../../dc/d4f/Settings_2Settings_8hpp.html#af48d0a4efaf52fc688a8ced019e561ef">SYSEX_BUFFER_SIZE</a>.</p>
<p >If you don't need support for multiple MIDI interfaces, you can set <code>DISABLE_PIPES</code> to <code>1</code>. This disables support for MIDI pipe routing, and causes Control Surface to use the default interface only.</p>
<p >If you're not using the <code>Control_Surface</code> instance, you can save memory by setting <code>CS_TRUE_CONTROL_SURFACE_INSTANCE</code> to <code>0</code>. This replaces <code>Control_Surface</code> by a macro that expands to a function call, rather than defining <code>Control_Surface</code> as a global variable. This allows the optimizer and the linker to optimize out parts of the library more effectively, but may reduce the quality of code completion. It does not affect the behavior of the library.</p>
<h1><a class="anchor" id="faq-midi-note-f"></a>
Why do I get a compiler error when using the note F?</h1>
<p >The Arduino core defines a global preprocessor macro <code>F(...)</code> which places string literals in flash memory. Unfortunately, macros do not follow the C++ syntax and scoping rules, so it means that it is impossible to create a constant or function with the name <code>F</code>, even in a separate namespace. Therefore, the note F can be referenced using the name <code>F_</code> (F underscore) instead of <code>F</code>.</p>
<p >If you get this wrong, you might get an error saying the following: </p><div class="fragment"><div class="line">In file included from /home/user/.arduino15/packages/arduino/hardware/avr/1.8.3/cores/arduino/Arduino.h:232:0,</div>
<div class="line">                 from /tmp/arduino-sketch-XXXXX/sketch/sketch.ino.cpp:1:</div>
<div class="line">/home/user/.arduino15/packages/arduino/hardware/avr/1.8.3/cores/arduino/WString.h:38:27: error: expected unqualified-id before &#39;(&#39; token</div>
<div class="line"> #define F(string_literal) (reinterpret_cast&lt;const __FlashStringHelper *&gt;(PSTR(string_literal)))</div>
<div class="line">                           ^</div>
<div class="line">sketch.ino: note: in expansion of macro &#39;F&#39;</div>
<div class="line">   { pin, MIDI_Notes::F(4) }</div>
<div class="line">                      ^</div>
</div><!-- fragment --><h1><a class="anchor" id="faq-control-surface-vs-midi-controller"></a>
What's the difference between the Control Surface and MIDI Controller libraries?</h1>
<p >You might already have found my other Arduino MIDI library, <a href="https://github.com/tttapa/MIDI_Controller">MIDI Controller</a>, and are wondering which one you should use for your project.</p>
<p >Short answer: Use Control Surface. MIDI Controller is no longer supported and Control Surface completely replaces every aspect of it.</p>
<p >For the long answer, first, some background: <br  />
 I first started working on the MIDI Controller library way back in 2015, and it evolved a lot early on. The library seemed to be pretty popular, and it worked pretty well, so I couldn't just push breaking changes every couple of months. <br  />
 Many people requested support for MIDI input, and I liked experimenting with it as well. The main problem was that the overall architecture of the library needed a complete overhaul in order to add MIDI input support. Since I didn't know if the MIDI input was going to work out, and I didn't want to break compatibility with older versions of the library, I decided to fork it: Control Surface was born.</p>
<p >I consider the MIDI Controller library obsolete. I won't be adding any new features, and I no longer offer support for it. <br  />
 For new projects, you should always use Control Surface, it is actively being developed, features are added, bugs are fixed, and I offer support for it on the Arduino forum and on GitHub.</p>
<p >The main difference between the two libraries is that Control Surface has much more features. MIDI Controller has everything you need for a working MIDI controller with potentiometers, push buttons, rotary encoders, etc., while Control Surface supports all of that, plus MIDI input, LEDs, VU meters, OLED displays, MIDI over Bluetooth, Audio over USB, etc. <br  />
 Another major difference is the documentation and tests. Control Surface tries to provide better documentation using Doxygen, and it has many unit tests to make sure I don't introduce any bugs. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
